% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/calcTD.R
\name{calcTD}
\alias{calcTD}
\title{Compute Dew Point Temperature (fast C++ core)}
\usage{
calcTD(
  airTemp,
  relativeHumidity,
  inputunits = "degC",
  outputunits = "degC",
  roundby = 2,
  returnWithUnits = TRUE,
  ignoreattr = FALSE,
  debug = FALSE
)
}
\arguments{
\item{airTemp}{Numeric vector of air temperature. May carry \code{attr(., "unit")}.}

\item{relativeHumidity}{Numeric vector of RH in percent (0â€“100).}

\item{inputunits}{Character; temperature units of \code{airTemp}. One of
\code{"degC"}, \code{"degF"}, \code{"K"}. Defaults to \code{"degC"}.}

\item{outputunits}{Character; desired dew point units. One of
\code{"degC"}, \code{"degF"}. Defaults to \code{"degC"}.}

\item{roundby}{Integer; number of decimal places to round the result (performed in C++).}

\item{returnWithUnits}{Logical; if \code{TRUE}, sets \code{attr(result, "unit")} to \code{outputunits}.}

\item{ignoreattr}{Logical; if \code{TRUE}, skip attribute checks and rely on \code{inputunits}.}

\item{debug}{Logical; if \code{TRUE}, emit a brief trace of unit decisions.}
}
\value{
Numeric vector of dew point in \code{outputunits}. If
\code{returnWithUnits = TRUE}, the result has \code{attr(x, "unit") = outputunits}.
}
\description{
Calculates dew point from air temperature and relative humidity using a C++
implementation. Inputs can be declared via \code{inputunits} and/or inferred
from \code{attr(x, "unit")} on \code{airTemp}. Output is returned in the
requested unit and, by default, tagged with a lightweight \code{"unit"} attribute.
}
\section{Unit handling}{

\itemize{
\item Recognized temperature tokens: \code{"degC"}, \code{"degF"}, \code{"K"}.
\item If \code{ignoreattr = FALSE} (default), the function reads
\code{attr(airTemp, "unit")} and enforces agreement with \code{inputunits}
when provided; otherwise it errors on conflict or missing attribute.
\item If \code{ignoreattr = TRUE}, the function trusts \code{inputunits}
(or the attribute if \code{inputunits} is missing).
\item Internally, the C++ core expects either \code{"degC"} or \code{"degF"}.
If \code{inputunits == "K"}, values are normalized to \code{"degC"}.
}
}

\examples{
# Simple vector (attribute-driven)
ta <- c(30, 31, 29); attr(ta, "unit") <- "degC"
rh <- c(50, 55, 60)
dpC <- calcTD(ta, rh, outputunits = "degC")
attr(dpC, "unit")  # "degC"

# Override: declare input as Fahrenheit, request Fahrenheit output
taF <- c(86, 88, 84); attr(taF, "unit") <- "degF"
dpF <- calcTD(taF, rh, inputunits = "degF", outputunits = "degF")

# Ignore attribute and trust inputunits
attr(taF, "unit") <- "degC"  # wrong on purpose
dp_ok <- calcTD(taF, rh, inputunits = "degF", outputunits = "degC", ignoreattr = TRUE)

# data.table pattern
if (requireNamespace("data.table", quietly = TRUE)) {
  DT <- data.table::data.table(ta = ta, rh = rh)
  attr(DT$ta, "unit") <- "degC"
  DT[, dp := calcTD(ta, rh, outputunits = "degC")]
  attr(DT$dp, "unit")
}

}
\seealso{
\code{\link{unit}} for lightweight unit tagging.
}
